# This Ghidra script does the following:
#
# - Parses the xml netprop output of the SourceMod command `sm_dump_netprops_xml`
# - Parses Linux binary `server_srv.so` for all vftables of classes that were found during netprop parsing 
#
# TODO:
#
# - Parse datamaps?

import xml.etree.ElementTree as ET
import docking.widgets.filechooser.GhidraFileChooser as GhidraFileChooser

dtm = currentProgram.getDataTypeManager()
sm = currentProgram.getSymbolTable()

# Parses the struct name (ex. `CBaseEntity`) and returns a list of virtual function names.
# TODO: Parse all structs? Execution might be faster than individually querying each struct.
def parse_vftable(struct_name):
    for symbol in sm.getAllSymbols(False):
        if symbol.getName() == "vtable" and symbol.getParentSymbol().getName() == struct_name:
            vftable = []
            vftable_fn_address = symbol.getAddress().add(8)    # TODO: Do not hardcode the 4 padding byte + 4 byte pointer.
            while True:
                try:
                    vfunc = getFunctionAt(getDataAt(vftable_fn_address).getValue())
                    vfunc_name = vfunc.getName()

                    # Avoid naming conflicts by assigning a digit to the virtual function name.
                    count = 0
                    for existing_vfunc in vftable:
                        if existing_vfunc["name"].startswith(vfunc_name):
                            count += 1
                    if count > 0:
                        vfunc_name += "_" + str(count)

                    vftable.append({
                        "name": vfunc_name,
                        "fn": vfunc,
                    })
                    vftable_fn_address = vftable_fn_address.add(4)    # TODO: Do not hardcode the 4 byte pointer.
                except:
                    break
            return vftable
    raise BaseException("Could not find vftable for class `" + struct_name + "`.")

# Creates a Ghidra data type.
def to_c_type(name, type, bits, flags):
    if type == "integer":
        if name.startswith("m_b"):
            return ghidra.program.model.data.BooleanDataType()
        if bits > 0 and bits <= 32:
            unsigned = flags.find("Unsigned") != -1
            if bits <= 8:
                return ghidra.program.model.data.UnsignedCharDataType() if unsigned else ghidra.program.model.data.CharDataType()
            elif bits <= 16:
                return ghidra.program.model.data.UnsignedShortDataType() if unsigned else ghidra.program.model.data.ShortDataType()
            elif bits <= 32:
                return ghidra.program.model.data.UnsignedIntegerDataType() if unsigned else ghidra.program.model.data.IntegerDataType()
    elif name.startswith("m_fl") or type == "float":
        return ghidra.program.model.data.FloatDataType()
    elif type == "string":
        return ghidra.program.model.data.PointerDataType(ghidra.program.model.data.CharDataType())
    elif name.startswith("m_vec") or type == "vector":
        return ghidra.program.model.data.ArrayDataType(ghidra.program.model.data.FloatDataType(), 3, 4)
    raise BaseException("Could not determine type `" + type + "` for netprop variable `" + name + "`.")

# Recursively parses a struct for all netprops.
def parse_xml_netprops_struct(variables, sendtable, table_offset):
    for property in sendtable.findall("property"):
        name = property.get("name")
        type = property.find("type").text
        offset = int(property.find("offset").text)
        bits = int(property.find("bits").text)
        flags = property.find("flags").text or ""

        # Inheritance.
        if name == "baseclass":
            parse_xml_netprops_struct(variables, property.find("sendtable"), 0)
        # This is a data table containing other offsets.
        elif type == "datatable":
            # Check whether offset overlaps with vftable or is an invalid offset.
            if offset > 4:
                parse_xml_netprops_struct(variables, property.find("sendtable"), table_offset + offset)
        # This is a member variable.
        else:
            # Fixes issues with m_vec...[] overlapping with m_vec....
            if name.endswith("]"):
                continue
            
            # Skip names that are only digits.
            # TODO: add support for subclasses.
            if name.isdigit():
                continue
            
            # Remove duplicates.
            if any(name == existing["name"] for existing in variables):
                continue

            # Check whether offset overlaps with vftable or is an invalid offset.
            if table_offset + offset <= 4:
                continue

            variables.append({
                "name": name,
                "type": to_c_type(name, type, bits, flags),
                "offset": table_offset + offset,
            })

# Parses the file generated by SourceMod command `sm_dump_netprops_xml`.
def parse_structs(xml_path):
    structs = []
    for serverclass in ET.parse(xml_path).getroot():
        name = serverclass.get("name")
        print("Parsing `" + name + "`...")
        vftable = parse_vftable(name)
        print("\tObtained `" + str(len(vftable)) + "` vftable entries.")
        struct = {
            "name": name,
            "vftable": vftable,
            "variables": [],
        }
        parse_xml_netprops_struct(struct["variables"], serverclass.find("sendtable"), 0)
        struct["variables"].sort(key=lambda variable: variable["offset"])
        print("\tObtained `" + str(len(struct["variables"])) + "` netprop entries.")
        structs.append(struct)
    return structs

file_chooser = GhidraFileChooser(None)
file_chooser.setTitle("Select XML netprop file")
for struct in parse_structs(file_chooser.getSelectedFile().getPath()):
    print("Writing struct `" + struct["name"] + "`...")
    data_type = dtm.getDataType("/Demangler/" + struct["name"])
    data_type.deleteAll()

    vftable_data_type = dtm.addDataType(ghidra.program.model.data.StructureDataType(ghidra.program.model.data.CategoryPath("/Demangler"), struct["name"] + "_vftable", 0), ghidra.program.model.data.DataTypeConflictHandler.REPLACE_HANDLER)
    for vfunc in struct["vftable"]:
        vfunc_data_type = vftable_data_type.add(ghidra.program.model.data.PointerDataType())
        vfunc_data_type.setFieldName(vfunc["name"])
        vfunc["fn"].setCallingConvention("__thiscall")
    vftable_data_component = data_type.insertAtOffset(0, ghidra.program.model.data.PointerDataType(vftable_data_type), 0)
    vftable_data_component.setFieldName("vftable")

    for variable in struct["variables"]:
        data_component = data_type.insertAtOffset(variable["offset"], variable["type"], 0)
        data_component.setFieldName(variable["name"])